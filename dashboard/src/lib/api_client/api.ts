/* tslint:disable */
/* eslint-disable */
/**
 * Podinate API
 * The API for the simple containerisation solution Podinate. Login should be performed over oauth from [auth.podinate.com](https://auth.podinate.com)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * The short name (slug/url) of the account. The account ID is globally unique and cannot be changed.
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * The human readable name of the account, used for display purposes.
     * @type {string}
     * @memberof Account
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The http code of the error message (400)
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
    /**
     * The human-readable description of what went wrong
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Pod
 */
export interface Pod {
    /**
     * The short name (slug/url) of the pod
     * @type {string}
     * @memberof Pod
     */
    'id'?: string;
    /**
     * The name of the pod
     * @type {string}
     * @memberof Pod
     */
    'name'?: string;
    /**
     * The container image to run for this pod
     * @type {string}
     * @memberof Pod
     */
    'image'?: string;
    /**
     * The image tag to run for this pod
     * @type {string}
     * @memberof Pod
     */
    'tag'?: string;
    /**
     * The current status of the pod
     * @type {string}
     * @memberof Pod
     */
    'status'?: string;
    /**
     * The date and time the pod was created
     * @type {string}
     * @memberof Pod
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * The short name (slug/url) of the project
     * @type {string}
     * @memberof Project
     */
    'id'?: string;
    /**
     * The name of the app
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     * The container image to run for this app
     * @type {string}
     * @memberof Project
     */
    'image'?: string;
    /**
     * The image tag to run for this app
     * @type {string}
     * @memberof Project
     */
    'tag'?: string;
}
/**
 * @type ProjectGet200ResponseInner
 * @export
 */
export type ProjectGet200ResponseInner = Project;

/**
 * @type ProjectProjectIdPodGet200ResponseInner
 * @export
 */
export type ProjectProjectIdPodGet200ResponseInner = Pod;

/**
 * 
 * @export
 * @interface UserGet200Response
 */
export interface UserGet200Response {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof UserGet200Response
     */
    'id'?: string;
    /**
     * The user\'s email address
     * @type {string}
     * @memberof UserGet200Response
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface UserLoginCompleteGet200Response
 */
export interface UserLoginCompleteGet200Response {
    /**
     * Whether the user is logged in or not
     * @type {boolean}
     * @memberof UserLoginCompleteGet200Response
     */
    'logged_in'?: boolean;
    /**
     * The user\'s API key, if they are logged in
     * @type {string}
     * @memberof UserLoginCompleteGet200Response
     */
    'api_key'?: string;
}
/**
 * 
 * @export
 * @interface UserLoginInitGet200Response
 */
export interface UserLoginInitGet200Response {
    /**
     * The URL to redirect the user to
     * @type {string}
     * @memberof UserLoginInitGet200Response
     */
    'url'?: string;
    /**
     * The token to use to get the user\'s actual API key once they have completed the oauth flow
     * @type {string}
     * @memberof UserLoginInitGet200Response
     */
    'token'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the account and all associated resources! This is irreversible and may be used for example when a client project has finished or a migration is complete.
         * @summary Delete the account and all associated resources!
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDelete: async (account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('accountDelete', 'account', account)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accounts are logically separate, distinct containers for different customers or teams. For example you might have an account for your marketing and product teams, or you might have an account for each client to separate their workloads. Accounts can have their own security settings applied.
         * @summary Get information about the current account.
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountGet: async (account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('accountGet', 'account', account)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing account, for example to change the display name
         * @summary Update an existing account
         * @param {string} account The account to use for the request
         * @param {Account} [account2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPatch: async (account: string, account2?: Account, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('accountPatch', 'account', account)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(account2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new logically separate account, for example for a given client or team.
         * @summary Create a new account
         * @param {Account} [account] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPost: async (account?: Account, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(account, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the account and all associated resources! This is irreversible and may be used for example when a client project has finished or a migration is complete.
         * @summary Delete the account and all associated resources!
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountDelete(account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountDelete(account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accounts are logically separate, distinct containers for different customers or teams. For example you might have an account for your marketing and product teams, or you might have an account for each client to separate their workloads. Accounts can have their own security settings applied.
         * @summary Get information about the current account.
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountGet(account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountGet(account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing account, for example to change the display name
         * @summary Update an existing account
         * @param {string} account The account to use for the request
         * @param {Account} [account2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountPatch(account: string, account2?: Account, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountPatch(account, account2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new logically separate account, for example for a given client or team.
         * @summary Create a new account
         * @param {Account} [account] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountPost(account?: Account, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountPost(account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Deletes the account and all associated resources! This is irreversible and may be used for example when a client project has finished or a migration is complete.
         * @summary Delete the account and all associated resources!
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDelete(account: string, options?: any): AxiosPromise<Account> {
            return localVarFp.accountDelete(account, options).then((request) => request(axios, basePath));
        },
        /**
         * Accounts are logically separate, distinct containers for different customers or teams. For example you might have an account for your marketing and product teams, or you might have an account for each client to separate their workloads. Accounts can have their own security settings applied.
         * @summary Get information about the current account.
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountGet(account: string, options?: any): AxiosPromise<Account> {
            return localVarFp.accountGet(account, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing account, for example to change the display name
         * @summary Update an existing account
         * @param {string} account The account to use for the request
         * @param {Account} [account2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPatch(account: string, account2?: Account, options?: any): AxiosPromise<Account> {
            return localVarFp.accountPatch(account, account2, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new logically separate account, for example for a given client or team.
         * @summary Create a new account
         * @param {Account} [account] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPost(account?: Account, options?: any): AxiosPromise<Account> {
            return localVarFp.accountPost(account, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Deletes the account and all associated resources! This is irreversible and may be used for example when a client project has finished or a migration is complete.
     * @summary Delete the account and all associated resources!
     * @param {string} account The account to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountDelete(account: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountDelete(account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accounts are logically separate, distinct containers for different customers or teams. For example you might have an account for your marketing and product teams, or you might have an account for each client to separate their workloads. Accounts can have their own security settings applied.
     * @summary Get information about the current account.
     * @param {string} account The account to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountGet(account: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountGet(account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing account, for example to change the display name
     * @summary Update an existing account
     * @param {string} account The account to use for the request
     * @param {Account} [account2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountPatch(account: string, account2?: Account, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountPatch(account, account2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new logically separate account, for example for a given client or team.
     * @summary Create a new account
     * @param {Account} [account] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountPost(account?: Account, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountPost(account, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PodApi - axios parameter creator
 * @export
 */
export const PodApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of pods for a given project. Pods are the individual running instances of a project, and are the smallest unit of deployment. For example, a project might have a pod running a Wordpress image, a Postgres Neon database, and a bucket for storing uploads.
         * @summary Get a list of pods for a given project
         * @param {string} projectId 
         * @param {string} account The account to use for the request
         * @param {number} [page] The page number to return (starts at 0)
         * @param {number} [limit] The amount of items to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodGet: async (projectId: string, account: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectProjectIdPodGet', 'projectId', projectId)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectProjectIdPodGet', 'account', account)
            const localVarPath = `/project/{project_id}/pod`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a pod
         * @summary Delete a pod
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodPodIdDelete: async (projectId: string, podId: string, account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdDelete', 'projectId', projectId)
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdDelete', 'podId', podId)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdDelete', 'account', account)
            const localVarPath = `/project/{project_id}/pod/{pod_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pod_id"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a pod by ID
         * @summary Get a pod by ID
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodPodIdGet: async (projectId: string, podId: string, account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdGet', 'projectId', projectId)
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdGet', 'podId', podId)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdGet', 'account', account)
            const localVarPath = `/project/{project_id}/pod/{pod_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pod_id"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a pod
         * @summary Update a pod
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {Pod} pod A JSON object containing the information needed to update a pod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodPodIdPatch: async (projectId: string, podId: string, account: string, pod: Pod, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdPatch', 'projectId', projectId)
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdPatch', 'podId', podId)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdPatch', 'account', account)
            // verify required parameter 'pod' is not null or undefined
            assertParamExists('projectProjectIdPodPodIdPatch', 'pod', pod)
            const localVarPath = `/project/{project_id}/pod/{pod_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pod_id"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pod, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creating a new pod
         * @summary Create a new pod
         * @param {string} projectId 
         * @param {string} account The account to use for the request
         * @param {Pod} pod A JSON object containing the information needed to create a new pod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodPost: async (projectId: string, account: string, pod: Pod, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectProjectIdPodPost', 'projectId', projectId)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectProjectIdPodPost', 'account', account)
            // verify required parameter 'pod' is not null or undefined
            assertParamExists('projectProjectIdPodPost', 'pod', pod)
            const localVarPath = `/project/{project_id}/pod`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pod, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PodApi - functional programming interface
 * @export
 */
export const PodApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PodApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of pods for a given project. Pods are the individual running instances of a project, and are the smallest unit of deployment. For example, a project might have a pod running a Wordpress image, a Postgres Neon database, and a bucket for storing uploads.
         * @summary Get a list of pods for a given project
         * @param {string} projectId 
         * @param {string} account The account to use for the request
         * @param {number} [page] The page number to return (starts at 0)
         * @param {number} [limit] The amount of items to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectProjectIdPodGet(projectId: string, account: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectProjectIdPodGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectProjectIdPodGet(projectId, account, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a pod
         * @summary Delete a pod
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectProjectIdPodPodIdDelete(projectId: string, podId: string, account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectProjectIdPodPodIdDelete(projectId, podId, account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a pod by ID
         * @summary Get a pod by ID
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectProjectIdPodPodIdGet(projectId: string, podId: string, account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectProjectIdPodPodIdGet(projectId, podId, account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a pod
         * @summary Update a pod
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {Pod} pod A JSON object containing the information needed to update a pod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectProjectIdPodPodIdPatch(projectId: string, podId: string, account: string, pod: Pod, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectProjectIdPodPodIdPatch(projectId, podId, account, pod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creating a new pod
         * @summary Create a new pod
         * @param {string} projectId 
         * @param {string} account The account to use for the request
         * @param {Pod} pod A JSON object containing the information needed to create a new pod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectProjectIdPodPost(projectId: string, account: string, pod: Pod, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectProjectIdPodPost(projectId, account, pod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PodApi - factory interface
 * @export
 */
export const PodApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PodApiFp(configuration)
    return {
        /**
         * Returns a list of pods for a given project. Pods are the individual running instances of a project, and are the smallest unit of deployment. For example, a project might have a pod running a Wordpress image, a Postgres Neon database, and a bucket for storing uploads.
         * @summary Get a list of pods for a given project
         * @param {string} projectId 
         * @param {string} account The account to use for the request
         * @param {number} [page] The page number to return (starts at 0)
         * @param {number} [limit] The amount of items to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodGet(projectId: string, account: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<ProjectProjectIdPodGet200ResponseInner>> {
            return localVarFp.projectProjectIdPodGet(projectId, account, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a pod
         * @summary Delete a pod
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodPodIdDelete(projectId: string, podId: string, account: string, options?: any): AxiosPromise<Pod> {
            return localVarFp.projectProjectIdPodPodIdDelete(projectId, podId, account, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a pod by ID
         * @summary Get a pod by ID
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodPodIdGet(projectId: string, podId: string, account: string, options?: any): AxiosPromise<Pod> {
            return localVarFp.projectProjectIdPodPodIdGet(projectId, podId, account, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a pod
         * @summary Update a pod
         * @param {string} projectId 
         * @param {string} podId 
         * @param {string} account The account to use for the request
         * @param {Pod} pod A JSON object containing the information needed to update a pod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodPodIdPatch(projectId: string, podId: string, account: string, pod: Pod, options?: any): AxiosPromise<Pod> {
            return localVarFp.projectProjectIdPodPodIdPatch(projectId, podId, account, pod, options).then((request) => request(axios, basePath));
        },
        /**
         * Creating a new pod
         * @summary Create a new pod
         * @param {string} projectId 
         * @param {string} account The account to use for the request
         * @param {Pod} pod A JSON object containing the information needed to create a new pod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdPodPost(projectId: string, account: string, pod: Pod, options?: any): AxiosPromise<Pod> {
            return localVarFp.projectProjectIdPodPost(projectId, account, pod, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PodApi - object-oriented interface
 * @export
 * @class PodApi
 * @extends {BaseAPI}
 */
export class PodApi extends BaseAPI {
    /**
     * Returns a list of pods for a given project. Pods are the individual running instances of a project, and are the smallest unit of deployment. For example, a project might have a pod running a Wordpress image, a Postgres Neon database, and a bucket for storing uploads.
     * @summary Get a list of pods for a given project
     * @param {string} projectId 
     * @param {string} account The account to use for the request
     * @param {number} [page] The page number to return (starts at 0)
     * @param {number} [limit] The amount of items to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodApi
     */
    public projectProjectIdPodGet(projectId: string, account: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return PodApiFp(this.configuration).projectProjectIdPodGet(projectId, account, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a pod
     * @summary Delete a pod
     * @param {string} projectId 
     * @param {string} podId 
     * @param {string} account The account to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodApi
     */
    public projectProjectIdPodPodIdDelete(projectId: string, podId: string, account: string, options?: AxiosRequestConfig) {
        return PodApiFp(this.configuration).projectProjectIdPodPodIdDelete(projectId, podId, account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a pod by ID
     * @summary Get a pod by ID
     * @param {string} projectId 
     * @param {string} podId 
     * @param {string} account The account to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodApi
     */
    public projectProjectIdPodPodIdGet(projectId: string, podId: string, account: string, options?: AxiosRequestConfig) {
        return PodApiFp(this.configuration).projectProjectIdPodPodIdGet(projectId, podId, account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a pod
     * @summary Update a pod
     * @param {string} projectId 
     * @param {string} podId 
     * @param {string} account The account to use for the request
     * @param {Pod} pod A JSON object containing the information needed to update a pod
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodApi
     */
    public projectProjectIdPodPodIdPatch(projectId: string, podId: string, account: string, pod: Pod, options?: AxiosRequestConfig) {
        return PodApiFp(this.configuration).projectProjectIdPodPodIdPatch(projectId, podId, account, pod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creating a new pod
     * @summary Create a new pod
     * @param {string} projectId 
     * @param {string} account The account to use for the request
     * @param {Pod} pod A JSON object containing the information needed to create a new pod
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodApi
     */
    public projectProjectIdPodPost(projectId: string, account: string, pod: Pod, options?: AxiosRequestConfig) {
        return PodApiFp(this.configuration).projectProjectIdPodPost(projectId, account, pod, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Projects are a container for individual resources. For example the my-cool-blog project might contain a pod running a Wordpress image, a Postgres Neon database, and a bucket for storing uploads.
         * @summary Returns a list of projects.
         * @param {string} account The account to use for the request
         * @param {number} [page] The page number to return (starts at 0)
         * @param {number} [limit] The amount of items to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectGet: async (account: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectGet', 'account', account)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to delete an existing project. This will delete all associated resources, and is irreversible. Use with caution!
         * @summary Delete an existing project
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIdDelete: async (id: string, account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectIdDelete', 'id', id)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectIdDelete', 'account', account)
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to see an existing project\'s configuration
         * @summary Get an existing project given by ID
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIdGet: async (id: string, account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectIdGet', 'id', id)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectIdGet', 'account', account)
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to update or edit an existing project. For example, you can update the tag to deploy when you have made and pushed a new build, or change the image to run entirely.
         * @summary Update an existing project
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIdPatch: async (id: string, account: string, project?: Project, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectIdPatch', 'id', id)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectIdPatch', 'account', account)
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creating a new project
         * @summary Create a new project
         * @param {string} account The account to use for the request
         * @param {Project} project A JSON object containing the information needed to create a new project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPost: async (account: string, project: Project, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('projectPost', 'account', account)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectPost', 'project', project)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * Projects are a container for individual resources. For example the my-cool-blog project might contain a pod running a Wordpress image, a Postgres Neon database, and a bucket for storing uploads.
         * @summary Returns a list of projects.
         * @param {string} account The account to use for the request
         * @param {number} [page] The page number to return (starts at 0)
         * @param {number} [limit] The amount of items to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectGet(account: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectGet(account, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows you to delete an existing project. This will delete all associated resources, and is irreversible. Use with caution!
         * @summary Delete an existing project
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectIdDelete(id: string, account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectIdDelete(id, account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows you to see an existing project\'s configuration
         * @summary Get an existing project given by ID
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectIdGet(id: string, account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectIdGet(id, account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows you to update or edit an existing project. For example, you can update the tag to deploy when you have made and pushed a new build, or change the image to run entirely.
         * @summary Update an existing project
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectIdPatch(id: string, account: string, project?: Project, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectIdPatch(id, account, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creating a new project
         * @summary Create a new project
         * @param {string} account The account to use for the request
         * @param {Project} project A JSON object containing the information needed to create a new project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectPost(account: string, project: Project, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectPost(account, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * Projects are a container for individual resources. For example the my-cool-blog project might contain a pod running a Wordpress image, a Postgres Neon database, and a bucket for storing uploads.
         * @summary Returns a list of projects.
         * @param {string} account The account to use for the request
         * @param {number} [page] The page number to return (starts at 0)
         * @param {number} [limit] The amount of items to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectGet(account: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<ProjectGet200ResponseInner>> {
            return localVarFp.projectGet(account, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to delete an existing project. This will delete all associated resources, and is irreversible. Use with caution!
         * @summary Delete an existing project
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIdDelete(id: string, account: string, options?: any): AxiosPromise<Project> {
            return localVarFp.projectIdDelete(id, account, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to see an existing project\'s configuration
         * @summary Get an existing project given by ID
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIdGet(id: string, account: string, options?: any): AxiosPromise<Project> {
            return localVarFp.projectIdGet(id, account, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to update or edit an existing project. For example, you can update the tag to deploy when you have made and pushed a new build, or change the image to run entirely.
         * @summary Update an existing project
         * @param {string} id 
         * @param {string} account The account to use for the request
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectIdPatch(id: string, account: string, project?: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.projectIdPatch(id, account, project, options).then((request) => request(axios, basePath));
        },
        /**
         * Creating a new project
         * @summary Create a new project
         * @param {string} account The account to use for the request
         * @param {Project} project A JSON object containing the information needed to create a new project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPost(account: string, project: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.projectPost(account, project, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * Projects are a container for individual resources. For example the my-cool-blog project might contain a pod running a Wordpress image, a Postgres Neon database, and a bucket for storing uploads.
     * @summary Returns a list of projects.
     * @param {string} account The account to use for the request
     * @param {number} [page] The page number to return (starts at 0)
     * @param {number} [limit] The amount of items to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectGet(account: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectGet(account, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to delete an existing project. This will delete all associated resources, and is irreversible. Use with caution!
     * @summary Delete an existing project
     * @param {string} id 
     * @param {string} account The account to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectIdDelete(id: string, account: string, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectIdDelete(id, account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to see an existing project\'s configuration
     * @summary Get an existing project given by ID
     * @param {string} id 
     * @param {string} account The account to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectIdGet(id: string, account: string, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectIdGet(id, account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to update or edit an existing project. For example, you can update the tag to deploy when you have made and pushed a new build, or change the image to run entirely.
     * @summary Update an existing project
     * @param {string} id 
     * @param {string} account The account to use for the request
     * @param {Project} [project] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectIdPatch(id: string, account: string, project?: Project, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectIdPatch(id, account, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creating a new project
     * @summary Create a new project
     * @param {string} account The account to use for the request
     * @param {Project} project A JSON object containing the information needed to create a new project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectPost(account: string, project: Project, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectPost(account, project, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the current user
         * @summary Get the current user
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('userGet', 'account', account)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (account != null) {
                localVarHeaderParameter['account'] = String(account);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete a user login and swap the given login token for an API key
         * @summary Complete a user login
         * @param {string} [token] The token given by /user/login/init to get the user\&#39;s actual API key once they have completed the oauth flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginCompleteGet: async (token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/login/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a login URL
         * @summary Get a login URL
         * @param {string} [provider] The oauth provider to use. Valid options will be github | gitlab | podinate, during alpha only podinate is allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginInitGet: async (provider?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/login/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the current user
         * @summary Get the current user
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Complete a user login and swap the given login token for an API key
         * @summary Complete a user login
         * @param {string} [token] The token given by /user/login/init to get the user\&#39;s actual API key once they have completed the oauth flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginCompleteGet(token?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginCompleteGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginCompleteGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a login URL
         * @summary Get a login URL
         * @param {string} [provider] The oauth provider to use. Valid options will be github | gitlab | podinate, during alpha only podinate is allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginInitGet(provider?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginInitGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginInitGet(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get the current user
         * @summary Get the current user
         * @param {string} account The account to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(account: string, options?: any): AxiosPromise<UserGet200Response> {
            return localVarFp.userGet(account, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete a user login and swap the given login token for an API key
         * @summary Complete a user login
         * @param {string} [token] The token given by /user/login/init to get the user\&#39;s actual API key once they have completed the oauth flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginCompleteGet(token?: string, options?: any): AxiosPromise<UserLoginCompleteGet200Response> {
            return localVarFp.userLoginCompleteGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a login URL
         * @summary Get a login URL
         * @param {string} [provider] The oauth provider to use. Valid options will be github | gitlab | podinate, during alpha only podinate is allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginInitGet(provider?: string, options?: any): AxiosPromise<UserLoginInitGet200Response> {
            return localVarFp.userLoginInitGet(provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get the current user
     * @summary Get the current user
     * @param {string} account The account to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGet(account: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGet(account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete a user login and swap the given login token for an API key
     * @summary Complete a user login
     * @param {string} [token] The token given by /user/login/init to get the user\&#39;s actual API key once they have completed the oauth flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLoginCompleteGet(token?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userLoginCompleteGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a login URL
     * @summary Get a login URL
     * @param {string} [provider] The oauth provider to use. Valid options will be github | gitlab | podinate, during alpha only podinate is allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLoginInitGet(provider?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userLoginInitGet(provider, options).then((request) => request(this.axios, this.basePath));
    }
}


