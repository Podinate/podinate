// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/podinate/terraform-provider-podinate/internal/sdk"
	"github.com/podinate/terraform-provider-podinate/internal/sdk/pkg/models/operations"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &PodDataSource{}
var _ datasource.DataSourceWithConfigure = &PodDataSource{}

func NewPodDataSource() datasource.DataSource {
	return &PodDataSource{}
}

// PodDataSource is the data source implementation.
type PodDataSource struct {
	client *sdk.SDK
}

// PodDataSourceModel describes the data model.
type PodDataSourceModel struct {
	Account     types.String          `tfsdk:"account"`
	CreatedAt   types.String          `tfsdk:"created_at"`
	Environment []EnvironmentVariable `tfsdk:"environment"`
	ID          types.String          `tfsdk:"id"`
	Image       types.String          `tfsdk:"image"`
	Name        types.String          `tfsdk:"name"`
	ProjectID   types.String          `tfsdk:"project_id"`
	ResourceID  types.String          `tfsdk:"resource_id"`
	Services    []Service             `tfsdk:"services"`
	Status      types.String          `tfsdk:"status"`
	Tag         types.String          `tfsdk:"tag"`
}

// Metadata returns the data source type name.
func (r *PodDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_pod"
}

// Schema defines the schema for the data source.
func (r *PodDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Pod DataSource",

		Attributes: map[string]schema.Attribute{
			"account": schema.StringAttribute{
				Required:    true,
				Description: `The account to use for the request`,
			},
			"created_at": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time the pod was created`,
			},
			"environment": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Computed:    true,
							Description: `The key of the environment variable`,
						},
						"value": schema.StringAttribute{
							Computed:    true,
							Description: `The value of the environment variable`,
						},
						"secret": schema.BoolAttribute{
							Computed:    true,
							Description: `Whether the value of the environment variable is a secret or not. If it is a secret, it will not be returned in the API response.`,
						},
					},
				},
				Description: `The environment variables to pass to the pod`,
			},
			"id": schema.StringAttribute{
				Required: true,
			},
			"image": schema.StringAttribute{
				Computed:    true,
				Description: `The container image to run for this pod`,
			},
			"name": schema.StringAttribute{
				Computed:    true,
				Description: `The name of the pod`,
			},
			"project_id": schema.StringAttribute{
				Required: true,
			},
			"resource_id": schema.StringAttribute{
				Computed:    true,
				Description: `The global Resource ID of the pod`,
			},
			"services": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Computed:    true,
							Description: `The hostname of the service`,
						},
						"port": schema.Int64Attribute{
							Computed:    true,
							Description: `The port to expose the service on`,
						},
						"target_port": schema.Int64Attribute{
							Computed:    true,
							Description: `The port to forward traffic to, if different from the port. Can be left blank if the same as the port.`,
						},
						"protocol": schema.StringAttribute{
							Computed:    true,
							Description: `The protocol to use for the service. Either http, tcp or udp.`,
						},
						"domain_name": schema.StringAttribute{
							Computed:    true,
							Description: `The domain name to use for the service. If left blank, the service will only be available internally. If set, the service will be available externally at the given domain name.`,
						},
					},
				},
				Description: `The services to expose for this pod`,
			},
			"status": schema.StringAttribute{
				Computed:    true,
				Description: `The current status of the pod`,
			},
			"tag": schema.StringAttribute{
				Computed:    true,
				Description: `The image tag to run for this pod`,
			},
		},
	}
}

func (r *PodDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *PodDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data *PodDataSourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Config.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	projectID := data.ProjectID.ValueString()
	podID := data.ID.ValueString()
	account := data.Account.ValueString()
	request := operations.GetProjectProjectIDPodPodIDRequest{
		ProjectID: projectID,
		PodID:     podID,
		Account:   account,
	}
	res, err := r.client.Pod.GetProjectProjectIDPodPodID(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.Pod == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromGetResponse(res.Pod)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
